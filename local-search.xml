<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java基础知识梳理一【Object类、常用API】-笔记</title>
    <link href="undefined2020/03/08/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E4%B8%80%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91-%E7%AC%94%E8%AE%B0/"/>
    <url>2020/03/08/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E4%B8%80%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java基础知识梳理一【Object类、常用API】"><a href="#Java基础知识梳理一【Object类、常用API】" class="headerlink" title="Java基础知识梳理一【Object类、常用API】"></a>Java基础知识梳理一【Object类、常用API】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>Object类</li><li>Date类</li><li>DateFormat类</li><li>Calendar类</li><li>System类</li><li>StringBuilder类</li><li>包装类</li></ul><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><p>-[ ] 能够说出Object类的特点<br>-[ ] 能够重写Object类的toString方法<br>-[ ] 能够重写Object类的equals方法<br>-[ ] 能够使用日期类输出当前日期<br>-[ ] 能够使用将日期格式化为字符串的方法<br>-[ ] 能够使用将字符串转换成日期的方法<br>-[ ] 能够使用System类的数组复制方法<br>-[ ] 能够使用System类获取当前毫秒时刻值<br>-[ ] 能够说出使用StringBuilder类可以解决的问题<br>-[ ] 能够使用StringBuilder进行字符串拼接操作<br>-[ ] 能够说出8种基本类型对应的包装类名称<br>-[ ] 能够说出自动装箱、自动拆箱的概念<br>-[ ] 能够将字符串转换为对应的基本类型<br>-[ ] 能够将基本类型转换为对应的字符串</p><h1 id="第一章-Object类"><a href="#第一章-Object类" class="headerlink" title="第一章 Object类"></a>第一章 Object类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p><p>如果一个类没有特别指定父类，    那么默认则继承自Object类。例如：</p><pre><code class="java">public class MyClass /*extends Object*/ {      // ...}</code></pre><p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：</p><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><h2 id="1-2-toString方法"><a href="#1-2-toString方法" class="headerlink" title="1.2 toString方法"></a>1.2 toString方法</h2><h3 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li></ul><p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p><p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p><h3 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h3><p>如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：</p><pre><code class="java">public class Person {      private String name;    private int age;    @Override    public String toString() {        return &quot;Person{&quot; + &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; + &quot;, age=&quot; + age + &#39;}&#39;;    }    // 省略构造器与Getter Setter}</code></pre><p>在IntelliJ IDEA中，可以点击<code>Code</code>菜单中的<code>Generate...</code>，也可以使用快捷键<code>alt+insert</code>，点击<code>toString()</code>选项。选择需要包含的成员变量并确定。如下图所示：</p><p><img src="img%5CtoString%E6%96%B9%E6%B3%95%E7%9A%84%E8%87%AA%E5%8A%A8%E9%87%8D%E5%86%99.bmp" srcset="/img/loading.gif" alt="toString方法的自动重写"></p><blockquote><p>小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。</p></blockquote><h2 id="1-3-equals方法"><a href="#1-3-equals方法" class="headerlink" title="1.3 equals方法"></a>1.3 equals方法</h2><h3 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p><h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的对象地址比较，只要不是同一个对象，结果必然为false。</p><h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：</p><pre><code class="java">import java.util.Objects;public class Person {        private String name;    private int age;    @Override    public boolean equals(Object o) {        // 如果对象地址一样，则认为相同        if (this == o)            return true;        // 如果参数为空，或者类型信息不一样，则认为不同        if (o == null || getClass() != o.getClass())            return false;        // 转换为当前类型        Person person = (Person) o;        // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果        return age == person.age &amp;&amp; Objects.equals(name, person.name);    }}</code></pre><p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用<code>Code</code>菜单中的<code>Generate…</code>选项，也可以使用快捷键<code>alt+insert</code>，并选择<code>equals() and hashCode()</code>进行自动代码生成。如下图所示：</p><p><img src="img%5Cequals%E6%96%B9%E6%B3%951.png" srcset="/img/loading.gif" alt=""></p><p><img src="img%5Cequals%E6%96%B9%E6%B3%952.png" srcset="/img/loading.gif" alt=""></p><p><img src="img%5Cequals%E6%96%B9%E6%B3%953.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>tips：Object类当中的hashCode等其他方法，今后学习。</p></blockquote><h2 id="1-4-Objects类"><a href="#1-4-Objects类" class="headerlink" title="1.4 Objects类"></a>1.4 Objects类</h2><p>在刚才IDEA自动重写equals代码中，使用到了<code>java.util.Objects</code>类，那么这个类是什么呢？</p><p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</p><p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p><ul><li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li></ul><p>我们可以查看一下源码，学习一下：</p><pre><code class="java">public static boolean equals(Object a, Object b) {      return (a == b) || (a != null &amp;&amp; a.equals(b));  }</code></pre><h1 id="第二章-日期时间类"><a href="#第二章-日期时间类" class="headerlink" title="第二章 日期时间类"></a>第二章 日期时间类</h1><h2 id="2-1-Date类"><a href="#2-1-Date类" class="headerlink" title="2.1 Date类"></a>2.1 Date类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>java.util.Date</code>类 表示特定的瞬间，精确到毫秒。</p><p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。</p><ul><li><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li><li><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li></ul><blockquote><p>tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p></blockquote><p>简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：</p><pre><code class="java">import java.util.Date;public class Demo01Date {    public static void main(String[] args) {        // 创建日期对象，把当前的时间        System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018        // 创建日期对象，把当前的毫秒值转成日期对象        System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970    }}</code></pre><blockquote><p>tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p></blockquote><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>Date类中的多数方法已经过时，常用的方法有：</p><ul><li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li></ul><h2 id="2-2-DateFormat类"><a href="#2-2-DateFormat类" class="headerlink" title="2.2 DateFormat类"></a>2.2 DateFormat类</h2><p><code>java.text.DateFormat</code> 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。</p><ul><li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象。</li><li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p><ul><li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li></ul><p>参数pattern是一个字符串，代表日期时间的自定义格式。</p><h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><p>常用的格式规则为：</p><table><thead><tr><th>标识字母（区分大小写）</th><th>含义</th></tr></thead><tbody><tr><td>y</td><td>年</td></tr><tr><td>M</td><td>月</td></tr><tr><td>d</td><td>日</td></tr><tr><td>H</td><td>时</td></tr><tr><td>m</td><td>分</td></tr><tr><td>s</td><td>秒</td></tr></tbody></table><blockquote><p>备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。</p></blockquote><p>创建SimpleDateFormat对象的代码如：</p><pre><code class="java">import java.text.DateFormat;import java.text.SimpleDateFormat;public class Demo02SimpleDateFormat {    public static void main(String[] args) {        // 对应的日期格式如：2018-01-16 15:06:38        DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    }    }</code></pre><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>DateFormat类的常用方法有：</p><ul><li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li><li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li></ul><h4 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h4><p>使用format方法的代码为：</p><pre><code class="java">import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/* 把Date对象转换成String*/public class Demo03DateFormatMethod {    public static void main(String[] args) {        Date date = new Date();        // 创建日期格式化对象,在获取格式化对象时可以指定风格        DateFormat df = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;);        String str = df.format(date);        System.out.println(str); // 2008年1月23日    }}</code></pre><h4 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a>parse方法</h4><p>使用parse方法的代码为：</p><pre><code class="java">import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/* 把String转换成Date对象*/public class Demo04DateFormatMethod {    public static void main(String[] args) throws ParseException {        DateFormat df = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;);        String str = &quot;2018年12月11日&quot;;        Date date = df.parse(str);        System.out.println(date); // Tue Dec 11 00:00:00 CST 2018    }}</code></pre><h2 id="2-3-练习"><a href="#2-3-练习" class="headerlink" title="2.3 练习"></a>2.3 练习</h2><p>请使用日期时间相关的API，计算出一个人已经出生了多少天。</p><p><strong>思路：</strong></p><p>1.获取当前时间对应的毫秒值</p><p>2.获取自己出生日期对应的毫秒值</p><p>3.两个时间相减（当前时间– 出生日期）</p><p><strong>代码实现：</strong></p><pre><code class="java">public static void function() throws Exception {    System.out.println(&quot;请输入出生日期 格式 YYYY-MM-dd&quot;);    // 获取出生日期,键盘输入    String birthdayString = new Scanner(System.in).next();    // 将字符串日期,转成Date对象    // 创建SimpleDateFormat对象,写日期模式    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);    // 调用方法parse,字符串转成日期对象    Date birthdayDate = sdf.parse(birthdayString);        // 获取今天的日期对象    Date todayDate = new Date();        // 将两个日期转成毫秒值,Date类的方法getTime    long birthdaySecond = birthdayDate.getTime();    long todaySecond = todayDate.getTime();    long secone = todaySecond-birthdaySecond;        if (secone &lt; 0){        System.out.println(&quot;还没出生呢&quot;);    } else {        System.out.println(secone/1000/60/60/24);    }}</code></pre><h2 id="2-4-Calendar类"><a href="#2-4-Calendar类" class="headerlink" title="2.4 Calendar类"></a>2.4 Calendar类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>日历我们都见过</p><p><img src="img%5C%E6%97%A5%E5%8E%86.jpg" srcset="/img/loading.gif" alt=""></p><p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p><h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：</p><p>Calendar静态方法</p><ul><li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历</li></ul><p>例如：</p><pre><code class="java">import java.util.Calendar;public class Demo06CalendarInit {    public static void main(String[] args) {        Calendar cal = Calendar.getInstance();    }    }</code></pre><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p>根据Calendar类的API文档，常用方法有：</p><ul><li><code>public int get(int field)</code>：返回给定日历字段的值。</li><li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li><li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li><li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li></ul><p>Calendar类中提供很多成员常量，代表给定的日历字段：</p><table><thead><tr><th>字段值</th><th>含义</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td></tr><tr><td>MONTH</td><td>月（从0开始，可以+1使用）</td></tr><tr><td>DAY_OF_MONTH</td><td>月中的天（几号）</td></tr><tr><td>HOUR</td><td>时（12小时制）</td></tr><tr><td>HOUR_OF_DAY</td><td>时（24小时制）</td></tr><tr><td>MINUTE</td><td>分</td></tr><tr><td>SECOND</td><td>秒</td></tr><tr><td>DAY_OF_WEEK</td><td>周中的天（周几，周日为1，可以-1使用）</td></tr></tbody></table><h4 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get/set方法"></a>get/set方法</h4><p>get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：</p><pre><code class="java">import java.util.Calendar;public class CalendarUtil {    public static void main(String[] args) {        // 创建Calendar对象        Calendar cal = Calendar.getInstance();        // 设置年         int year = cal.get(Calendar.YEAR);        // 设置月        int month = cal.get(Calendar.MONTH) + 1;        // 设置日        int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;);    }    }</code></pre><pre><code class="java">import java.util.Calendar;public class Demo07CalendarMethod {    public static void main(String[] args) {        Calendar cal = Calendar.getInstance();        cal.set(Calendar.YEAR, 2020);        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); // 2020年1月17日    }}</code></pre><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：</p><pre><code class="java">import java.util.Calendar;public class Demo08CalendarMethod {    public static void main(String[] args) {        Calendar cal = Calendar.getInstance();        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); // 2018年1月17日        // 使用add方法        cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天        cal.add(Calendar.YEAR, -3); // 减3年        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); // 2015年1月18日;     }}</code></pre><h4 id="getTime方法"><a href="#getTime方法" class="headerlink" title="getTime方法"></a>getTime方法</h4><p>Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。</p><pre><code class="java">import java.util.Calendar;import java.util.Date;public class Demo09CalendarMethod {    public static void main(String[] args) {        Calendar cal = Calendar.getInstance();        Date date = cal.getTime();        System.out.println(date); // Tue Jan 16 16:03:09 CST 2018    }}</code></pre><blockquote><p>小贴士：</p><p>​     西方星期的开始为周日，中国为周一。</p><p>​     在Calendar类中，月份的表示是以0-11代表1-12月。</p><p>​     日期是有大小关系的，时间靠后，时间越大。</p></blockquote><h1 id="第三章-System类"><a href="#第三章-System类" class="headerlink" title="第三章 System类"></a>第三章 System类</h1><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：</p><ul><li><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</li><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><h2 id="3-1-currentTimeMillis方法"><a href="#3-1-currentTimeMillis方法" class="headerlink" title="3.1 currentTimeMillis方法"></a>3.1 currentTimeMillis方法</h2><p>实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p><pre><code class="java">import java.util.Date;public class SystemDemo {    public static void main(String[] args) {           //获取当前时间毫秒值        System.out.println(System.currentTimeMillis()); // 1516090531144    }}</code></pre><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>验证for循环打印数字1-9999所需要使用的时间（毫秒）</p><pre><code class="java">public class SystemTest1 {    public static void main(String[] args) {        long start = System.currentTimeMillis();        for (int i = 0; i &lt; 10000; i++) {            System.out.println(i);        }        long end = System.currentTimeMillis();        System.out.println(&quot;共耗时毫秒：&quot; + (end - start));    }}</code></pre><h2 id="3-2-arraycopy方法"><a href="#3-2-arraycopy方法" class="headerlink" title="3.2 arraycopy方法"></a>3.2 arraycopy方法</h2><ul><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><p>数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：</p><table><thead><tr><th>参数序号</th><th>参数名称</th><th>参数类型</th><th>参数含义</th></tr></thead><tbody><tr><td>1</td><td>src</td><td>Object</td><td>源数组</td></tr><tr><td>2</td><td>srcPos</td><td>int</td><td>源数组索引起始位置</td></tr><tr><td>3</td><td>dest</td><td>Object</td><td>目标数组</td></tr><tr><td>4</td><td>destPos</td><td>int</td><td>目标数组索引起始位置</td></tr><tr><td>5</td><td>length</td><td>int</td><td>复制元素个数</td></tr></tbody></table><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]</p><pre><code class="java">import java.util.Arrays;public class Demo11SystemArrayCopy {    public static void main(String[] args) {        int[] src = new int[]{1,2,3,4,5};        int[] dest = new int[]{6,7,8,9,10};        System.arraycopy( src, 0, dest, 0, 3);        /*代码运行后：两个数组中的元素发生了变化         src数组元素[1,2,3,4,5]         dest数组元素[1,2,3,9,10]        */    }}</code></pre><h1 id="第四章-StringBuilder类"><a href="#第四章-StringBuilder类" class="headerlink" title="第四章 StringBuilder类"></a>第四章 StringBuilder类</h1><h2 id="4-1-字符串拼接问题"><a href="#4-1-字符串拼接问题" class="headerlink" title="4.1 字符串拼接问题"></a>4.1 字符串拼接问题</h2><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p><pre><code class="java">public class StringDemo {    public static void main(String[] args) {        String s = &quot;Hello&quot;;        s += &quot;World&quot;;        System.out.println(s);    }}</code></pre><p>在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p><p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p><p><img src="img%5CString%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98.bmp" srcset="/img/loading.gif" alt=""></p><p>由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p><h2 id="4-2-StringBuilder概述"><a href="#4-2-StringBuilder概述" class="headerlink" title="4.2 StringBuilder概述"></a>4.2 StringBuilder概述</h2><p>查阅<code>java.lang.StringBuilder</code>的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p><p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p><p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)</p><p><img src="img%5C06-StringBuilder%E7%9A%84%E5%8E%9F%E7%90%86.png" srcset="/img/loading.gif" alt="06-StringBuilder的原理"></p><h2 id="4-3-构造方法"><a href="#4-3-构造方法" class="headerlink" title="4.3 构造方法"></a>4.3 构造方法</h2><p>根据StringBuilder的API文档，常用构造方法有2个：</p><ul><li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li><li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li></ul><pre><code class="java">public class StringBuilderDemo {    public static void main(String[] args) {        StringBuilder sb1 = new StringBuilder();        System.out.println(sb1); // (空白)        // 使用带参构造        StringBuilder sb2 = new StringBuilder(&quot;itcast&quot;);        System.out.println(sb2); // itcast    }}</code></pre><h2 id="4-4-常用方法"><a href="#4-4-常用方法" class="headerlink" title="4.4 常用方法"></a>4.4 常用方法</h2><p>StringBuilder常用的方法有2个：</p><ul><li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li><li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li></ul><h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：</p><pre><code class="java">public class Demo02StringBuilder {    public static void main(String[] args) {        //创建对象        StringBuilder builder = new StringBuilder();        //public StringBuilder append(任意类型)        StringBuilder builder2 = builder.append(&quot;hello&quot;);        //对比一下        System.out.println(&quot;builder:&quot;+builder);        System.out.println(&quot;builder2:&quot;+builder2);        System.out.println(builder == builder2); //true        // 可以添加 任何类型        builder.append(&quot;hello&quot;);        builder.append(&quot;world&quot;);        builder.append(true);        builder.append(100);        // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。        // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下        //链式编程        builder.append(&quot;hello&quot;).append(&quot;world&quot;).append(true).append(100);        System.out.println(&quot;builder:&quot;+builder);    }}</code></pre><blockquote><p>备注：StringBuilder已经覆盖重写了Object当中的toString方法。</p></blockquote><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：</p><pre><code class="java">public class Demo16StringBuilder {    public static void main(String[] args) {        // 链式创建        StringBuilder sb = new StringBuilder(&quot;Hello&quot;).append(&quot;World&quot;).append(&quot;Java&quot;);        // 调用方法        String str = sb.toString();        System.out.println(str); // HelloWorldJava    }}</code></pre><h1 id="第五章-包装类"><a href="#第五章-包装类" class="headerlink" title="第五章 包装类"></a>第五章 包装类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于java.lang包中）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h2 id="5-2-装箱与拆箱"><a href="#5-2-装箱与拆箱" class="headerlink" title="5.2 装箱与拆箱"></a>5.2 装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p><ul><li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p></li><li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p></li></ul><p>用Integer与 int为例：（看懂代码即可）</p><p>基本数值—-&gt;包装对象</p><pre><code class="java">Integer i = new Integer(4);//使用构造函数函数Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法</code></pre><p>包装对象—-&gt;基本数值</p><pre><code class="java">int num = i.intValue();</code></pre><h2 id="5-3自动装箱与自动拆箱"><a href="#5-3自动装箱与自动拆箱" class="headerlink" title="5.3自动装箱与自动拆箱"></a>5.3自动装箱与自动拆箱</h2><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p><pre><code class="java">Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。</code></pre><h2 id="5-3-基本类型与字符串之间的转换"><a href="#5-3-基本类型与字符串之间的转换" class="headerlink" title="5.3 基本类型与字符串之间的转换"></a>5.3 基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><p>   基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： </p><pre><code>基本类型直接与””相连接即可；如：34+&quot;&quot;</code></pre><p>String转换成对应的基本类型 </p><p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p><ul><li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li><li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li><li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li><li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li><li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li><li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li><li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li></ul><p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p><pre><code class="java">public class Demo18WrapperParse {    public static void main(String[] args) {        int num = Integer.parseInt(&quot;100&quot;);    }}</code></pre><blockquote><p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java学习记录</title>
    <link href="undefined2019/12/19/Java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>2019/12/19/Java%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Java的内存需要划分成为5个部分："><a href="#Java的内存需要划分成为5个部分：" class="headerlink" title="Java的内存需要划分成为5个部分："></a>Java的内存需要划分成为5个部分：</h1><h2 id="栈（Stack）-存放的都是方法中的局部变量。"><a href="#栈（Stack）-存放的都是方法中的局部变量。" class="headerlink" title="栈（Stack）:存放的都是方法中的局部变量。"></a>栈（Stack）:存放的都是方法中的局部变量。</h2><p>存在于常规内存 RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存，这是一种快速有效的内存分配方法，速度仅次于寄存器。创建程序时，Java 系统必须准确地知道栈内保存的所有项的生命周期。这种约束限制了程序的灵活性。因此，虽然在栈内存上存在一些 Java 数据，特别是对象引用，但 Java 对象却是保存在堆内存的。<br>        局部变量：方法的参数，或者是方法{}内部的变量<br>        作用域：一旦超出作用域，立刻从栈内存当中消失。</p><h2 id="堆（Heap）：凡是new出来的东西，都在堆当中"><a href="#堆（Heap）：凡是new出来的东西，都在堆当中" class="headerlink" title="堆（Heap）：凡是new出来的东西，都在堆当中"></a>堆（Heap）：凡是new出来的东西，都在堆当中</h2><p>这是一种通用的内存池（也在 RAM 区域），所有 Java 对象都存在于其中。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，用堆内存保存数据更具灵活性。创建一个对象时，只需用 new 命令实例化对象即可，当执行代码时，会自动在堆中进行内存分配。这种灵活性是有代价的：分配和清理堆内存要比栈内存需要更多的时间（如果可以用 Java 在栈内存上创建对象，就像在 C++ 中那样的话）。随着时间的推移，Java 的堆内存分配机制现在已经非常快，因此这不是一个值得关心的问题了。</p><pre><code>    堆内存里面的东西都有一个地址值：16进制    堆内存里面的数据，都有默认值。规则：        如果是整数          默认为0        如果是浮点数        默认为0.0        如果是字符          默认为&#39;\u0000&#39;        如果是布尔          默认为false        如果是引用类型      默认为null</code></pre><h2 id="方法区（Met。hod-Area）"><a href="#方法区（Met。hod-Area）" class="headerlink" title="方法区（Met。hod Area）:"></a>方法区（Met。hod Area）:</h2><pre><code>    存储.class相关信息，包含方法的信息。</code></pre><h2 id="本地方法栈（Native-Method-Stack）："><a href="#本地方法栈（Native-Method-Stack）：" class="headerlink" title="本地方法栈（Native Method Stack）："></a>本地方法栈（Native Method Stack）：</h2><pre><code>    与操作系统相关。</code></pre><h2 id="寄存器（Pc-Register）："><a href="#寄存器（Pc-Register）：" class="headerlink" title="寄存器（Pc Register）："></a>寄存器（Pc Register）：</h2><pre><code>    与Pc相关。    最快的存储区域，位于 CPU 内部 ^2。然而，寄存器的数量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权，也无法在自己的程序里找到寄存器存在的踪迹</code></pre><h1 id="局部变量和成员变量"><a href="#局部变量和成员变量" class="headerlink" title="局部变量和成员变量"></a>局部变量和成员变量</h1><p>1.定义的位置不一样【重点】<br>局部变量： 在方法的内部<br>成员变量： 在方法的外部，直接写在类当中</p><p>2.作用范围不一样【重点】<br>局部变量: 只有方法当中才可以使用，出了方法就不能使用了<br>成员变量: 整个类全都可以使用</p><p>3.默认值不一样【重点】<br>局部变量： 没有默认值，如果想要使用，必须手动进行赋值<br>成员变量： 如果没有赋值，会有默认值，规则和数组一样</p><p>4.内存的位置不一样（了解）<br>局部变量： 位于栈内存<br>成员变量:  位于堆内存</p><p>5生命周期不一样（了解）<br>局部变量： 随着方法进栈而诞生，随着方法出栈而消失<br>成员变量： 随着对象创建而诞生，随着对象被垃圾回收而消失</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是多个的公共类。<br>接口是一种引用数据类型，最重要的内容就是其中的： 抽象方法</p><p>如何定义一个接口的格式：<br>Public interface 接口名称 {<br>        //接口内容<br>}</p><p>备注： 换成了关键字interface之后，编译生成的字节码文件仍然是： .java –&gt; .class.</p><p>如果是Java7， 那么接口中可以包含的内容有：</p><ol><li>常量</li><li>抽象方法</li></ol><p>如果是Java8， 还可以额外包含：<br>3. 默认方法<br>4.静态方法</p><p>如果是Java9 ，还可以额外包含:<br>5.私有方法</p><h1 id="接口使用步骤："><a href="#接口使用步骤：" class="headerlink" title="接口使用步骤："></a>接口使用步骤：</h1><ol><li>接口不能直接使用，必须有一个 “实现类”来 “实现”该接口</li></ol><p>格式：<br>public class 实现类名称 implements 接口名称 {<br>    //…..<br>}<br>2.接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。<br>3.创建实现类的对象，进行使用。</p><p>注意事项：<br>如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo+Github搭建教程</title>
    <link href="undefined2019/12/04/hexo-Github%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    <url>2019/12/04/hexo-Github%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="安装所需要的软件"><a href="#安装所需要的软件" class="headerlink" title="安装所需要的软件"></a>安装所需要的软件</h1><p>1.安装<a href="https://nodejs.org/en/" target="blank">Node.js</a><br>    <img src="/2019/12/04/hexo-Github%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/node1.png" srcset="/img/loading.gif" class="" title="下载自己电脑对应版本，然后一直next就可了"><br>2.安装<a href="https://git-scm.com/" target="blank">Git管理工具</a><br>     <img src="/2019/12/04/hexo-Github%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/git.png" srcset="/img/loading.gif" class="" title="下载自己电脑对应版本，然后一直next就可了"></p><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>上面的安装完之后，电脑桌面右键，打开Git Bash here<br>    <img src="/2019/12/04/hexo-Github%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/git1.png" srcset="/img/loading.gif" class=""></p><pre><code>$ npm install -g hexo-cli</code></pre><h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><pre><code>$ cd：D:$ hexo init &lt;文件名字&gt;$ cd &lt;folder&gt;$ npm install</code></pre><p>新建完成后，在D盘目录可以看看到刚才所创建的文件名字，打开文件夹目录结构如下：</p><pre><code>.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><p>现在回到命令窗口，使用一下命令，开启本地预览服务<br>    $ hexo s<br>运行之后打开游览器输入<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 就可以看到下面这个页面，就成功了。<br>    <img src="/2019/12/04/hexo-Github%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/01.png" srcset="/img/loading.gif" class="" title="出现此页面就成功了"></p><p>到这里我们的博客已经在我们的本地搭建好了，但是我们的博客不可能一直自己访问，同时也要展示给其他人看，接下来介绍一下怎么免费的部署到网络上面去，让大家可以访问到你的网站。</p><h1 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h1><p>首先大家要先去注册一个<a href="https://github.com/" target="blank">Github</a>账号，注册如果遇到了问题或者不会注册的可以百度一下。</p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><img src="/2019/12/04/hexo-Github%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/02.png" srcset="/img/loading.gif" class="" title="点击加号选择第一个NEW repository"><img src="/2019/12/04/hexo-Github%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/03.png" srcset="/img/loading.gif" class="" title="创建仓库"><p>创建完仓库之后如下</p><img src="/2019/12/04/hexo-Github%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/04.png" srcset="/img/loading.gif" class="" title="创建仓库"><h2 id="创建SSH-KEY"><a href="#创建SSH-KEY" class="headerlink" title="创建SSH KEY"></a>创建SSH KEY</h2><p>在用户主目录下（C:\Users\Administrator），看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Git Bas，创建SSH Key：</p><pre><code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></pre><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。<br>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><p>然后打开我们的Github,如下图所示<br>    {% asset_img 05.png 如图所示 %}<br>    {% asset_img 06.png 如图所示 %}<br>上面的操作完成后，接下来在我们的用户目录找到.ssh目录下面的id_rsa.pub打开，复制内容然粘贴在下面②号标记点</p><pre><code>{% asset_img 07.png 添加id_rsa.pub %}</code></pre><p>接下来让我们回到Git Bash进行如下的配置</p><pre><code>$ git config --global user.name &quot;***&quot;// 你的github用户名，非昵称$ git config --global user.email  &quot;xxx@qq.com&quot;// 填写你的github注册邮箱</code></pre><h2 id="推送到Github仓库"><a href="#推送到Github仓库" class="headerlink" title="推送到Github仓库"></a>推送到Github仓库</h2><p>找到我们的所创建的博客文件，打开目录找到根目录下面的_config.yml文件，在文件的最下面进行让如下的配置</p><pre><code> deploy:   type: git   repo: //这个地方填写上面我们创建仓库的时候生成的地址   branch: master</code></pre><p>上面的操作完成后我，进行Git Bash操作，执行</p><pre><code>$ hexo d</code></pre><p>执行操作完成后，我们可以看到我们的仓库就会出现相对应的内容，这个时候我们已经将我们的博客推送到我们的Github了，接下面的我们就可以用我们创建好的名字进行访问了。</p><h1 id="hexo主题"><a href="#hexo主题" class="headerlink" title="hexo主题"></a>hexo主题</h1><p>在这里简单说一下hexo主题的配置,这里推荐一下用的比较多的<a href="https://github.com/litten/hexo-theme-yilia" target="blank">Yilia</a>主题</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p> 两种安装方式<br> 第一种打开Git Bash执行下面的命令即安装</p><pre><code>$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code></pre><p>第二种，进入到主题的Github，直接下载压缩包</p><img src="/2019/12/04/hexo-Github%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/08.png" srcset="/img/loading.gif" class="" title="如图所示"><p>下载完成后解压压缩包将文件名字改为yilia，然后放到我们的博客文件里面的themes文件夹下面，然后打开我们根目录下面的_config.yml配置文件修改</p><pre><code>theme: yilia</code></pre><p>到此我们的主题已经更换好了，主题的配置可以参考官方的主题是配置教程。<br>#绑定域名<br>购买域名，域名可以在百度云，腾讯云，阿里云等购买，关于的域名解析大家可以百度</p><h2 id="添加CNAME文件"><a href="#添加CNAME文件" class="headerlink" title="添加CNAME文件"></a>添加CNAME文件</h2><p>在hexo的source文件內，添加CNAME文件，记得不需要添加任何后缀。<br> {% asset_img 09.png 如图所示 %}</p><p>然后在文件中，输入域名信息，不需要添加http://<br>添加完成后，重新部署到github中</p><pre><code>$ hexo g$ hexo d</code></pre><p>在 github 上面，打开 username.github.io 项目的（Settings）设置，然后在 GitHub Pages的 Custom domain设置里填上购买的域名。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/12/01/hello-world/"/>
    <url>2019/12/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>